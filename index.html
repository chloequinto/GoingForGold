<html>

<head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <script src="p5.js"></script>
    <!-- <script src="ffmpegserver.js"></script>
    <script src="CCapture.js"></script> -->
    <!--<script src="ffmpegserver.js/dist/CCapture.js"></script>
    <script src="ffmpegserver.js/dist/ffmpegserver.min.js"></script>-->
    <!-- <script scr="index.js"></script> -->
</head>

<body>
    <h1> Please Wait to Download Until You See: Finished Computation Click Download Button </h1>
    
    <video id="video" src="/video/tennis_serving.mp4"></video>
    <canvas id="thecanvas" width="800" height="600"></canvas>
    <button onClick=downloadMahCSV()>Download CSV</button>
    <div id="FinishedCompute"></div>
</body>

<script>
    //Variables
    var keypoints;
    var tStamp =0; 
    var minPartConfidence;
    var count = 0;
    var count1 = 0;
    var addT = 0;
    var csvContent;
    var encodedUri;
    var link;
    var iter;
    var temp = 0;
    // var poseTime = 0;

    // var points = [];
    //var fps = 30;
    // var capturer = new CCapture({
    //    format: 'ffmpegserver',
    //  framerate: 60,
    //extension: ".mp4",
    // codec: "mpeg4",
    //});


    function setup() {
        createCanvas(800, 600);
        tStamp = 0;
        minPartConfidence = 0.3; //Threshold for bad confidence
    }

    video.addEventListener('loadeddata', function() {
        this.currentTime = tStamp; //current time is set to tStamp which is at 0 when loadeddata is started 
        console.log("Loading Completed!!")
        var duration = video.duration; //full time length of video
        console.log("Video Duration: ", duration)
        iter = 0;
        count1++;
        var interval = setInterval(function() {
            video.currentTime = iter;
            generateThumbnail(iter);
            iter = iter + 1;
            if (iter > duration) clearInterval(interval); //tStamp is the duration of the video
        }, 200);

    });

    function generateThumbnail(tStamp) {
        /**
            Generate new image with posenet given the time iterator 
        **/
        var context = thecanvas.getContext('2d');

        context.drawImage(video, 0, 0, 800, 600); //Dimensions 800 x 600 

        var dataURL = thecanvas.toDataURL();

        var img = document.createElement('img');

        img.setAttribute('src', dataURL);

        document.getElementById('thecanvas').appendChild(img); //Places the new generated image right next to 'thecanvas'

        posenet.load().then(function(net) { //Posenet
            temp++;
            const pose = net.estimateSinglePose(img, {
                flipHorizontal: false
            });
            return pose;
        }).then(function(pose) {
     

            console.log(pose);
            keypoints = pose.keypoints; //different x,y values; keypoint is array

            //the following lines are from draw function which is not commented out.
            //for some reason keypoints variable was declared as undefined otherwise.

            collect();
            var context = defaultCanvas0.getContext('2d');

            context.clearRect(0, 0, 600, 800);


            fill(0, 150, 150);
            noStroke();
            for (i = 0; i <= bits.length; i += 2) {
                ellipse(bits[i], bits[i + 1], 10, 10);
            }

            strokeWeight(4);

            // Left side
            stroke(0, 0, 255);
            line(bits[0], bits[1], bits[4], bits[5]); // left wrist to left elbow
            line(bits[4], bits[5], bits[20], bits[21]); // left elbow to left shoulder
            line(bits[20], bits[21], bits[8], bits[9]); // left shoulder to left hip
            line(bits[8], bits[9], bits[12], bits[13]); // left hip to left knee
            line(bits[12], bits[13], bits[16], bits[17]); //left knee to left ankle

            // Right side
            stroke(255, 0, 0);
            line(bits[2], bits[3], bits[6], bits[7]); // right wrist to right elbow
            line(bits[6], bits[7], bits[22], bits[23]); // right elbow to right shoulder
            line(bits[22], bits[23], bits[10], bits[11]); // right shoulder to right hip
            line(bits[10], bits[11], bits[14], bits[15]); // right hip to right knee
            line(bits[14], bits[15], bits[18], bits[19]); // right knee to right ankle

            // Middle side
            stroke(128, 0, 128);
            line(bits[20], bits[21], bits[22], bits[23]); // left shoulder to right shoulder
            line(bits[8], bits[9], bits[10], bits[11]); // left hip to right hip

            count++;
            console.log("Number of Poses: ", count);

            csvContent = "data:text/csv;charset=utf-8,";

            points.forEach(function(pArray) {
                p = pArray.join(",");
                csvContent += p + "\r\n";
            });

            var encodedUri = encodeURI(csvContent);
            link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "my_data.csv");
            document.body.appendChild(link); // Required for FF

            // console.log("count....", count, "VS temp...", temp);

            //HARD CODED #92 to get all frames counted by current video
            // if (count == temp && count == 92) {
            //     console.log("-----LOCATION CHANGE 2 -----");
            //     console.log("printing", count1);
            //     console.log("downloading here... numero 2 location....");

            //     link.click();
            // }
            // capturer.stop();
            //capturer.save();
            //return;
        })
    }

    var bits = [];
    var points = [];

    function collect() {
        for (var i = 0; i < keypoints.length; i++) {
            var keypoint = keypoints[i];
            if (keypoint.score > minPartConfidence) {
                if (i == posenet.partIds['leftWrist']) {
                    var LWristX = keypoint.position.x;
                    var LWristY = keypoint.position.y;
                    bits[0] = LWristX;
                    bits[1] = LWristY;
                    points.push([count, LWristX, LWristY]);
                }
                if (i == posenet.partIds['rightWrist']) {
                    var RWristX = keypoint.position.x;
                    var RWristY = keypoint.position.y;
                    bits[2] = RWristX;
                    bits[3] = RWristY;
                    points.push([count, RWristX, RWristY]);
                }
                if (i == posenet.partIds['leftElbow']) {
                    var LElbowX = keypoint.position.x;
                    var LElbowY = keypoint.position.y;
                    bits[4] = LElbowX;
                    bits[5] = LElbowY;
                    points.push([count, LElbowX, LElbowY]);
                }
                if (i == posenet.partIds['rightElbow']) {
                    var RElbowX = keypoint.position.x;
                    var RElbowY = keypoint.position.y;
                    bits[6] = RElbowX;
                    bits[7] = RElbowY;
                    points.push([count, RElbowX, RElbowY]);
                }
                if (i == posenet.partIds['leftHip']) {
                    var LHipX = keypoint.position.x;
                    var LHipY = keypoint.position.y;
                    bits[8] = LHipX;
                    bits[9] = LHipY;
                    points.push([count, LHipX, LHipY]);
                }
                if (i == posenet.partIds['rightHip']) {
                    var RHipX = keypoint.position.x;
                    var RHipY = keypoint.position.y;
                    bits[10] = RHipX;
                    bits[11] = RHipY;
                    points.push([count, RHipX, RHipY]);
                }
                if (i == posenet.partIds['leftKnee']) {
                    var LKneeX = keypoint.position.x;
                    var LKneeY = keypoint.position.y;
                    bits[12] = LKneeX;
                    bits[13] = LKneeY;
                    points.push([count, LKneeX, LKneeY]);
                }
                if (i == posenet.partIds['rightKnee']) {
                    var RKneeX = keypoint.position.x;
                    var RKneeY = keypoint.position.y;
                    bits[14] = RKneeX;
                    bits[15] = RKneeY;
                    points.push([count, RKneeX, RKneeY]);
                }
                if (i == posenet.partIds['leftAnkle']) {
                    var LAnkleX = keypoint.position.x;
                    var LAnkleY = keypoint.position.y;
                    bits[16] = LAnkleX;
                    bits[17] = LAnkleY;
                    points.push([count, LAnkleX, LAnkleY]);
                }
                if (i == posenet.partIds['rightAnkle']) {
                    var RAnkleX = keypoint.position.x;
                    var RAnkleY = keypoint.position.y;
                    bits[18] = RAnkleX;
                    bits[19] = RAnkleY;
                    points.push([count, RAnkleX, RAnkleY]);
                }
                if (i == posenet.partIds['leftShoulder']) {
                    var LShoulderX = keypoint.position.x;
                    var LShoulderY = keypoint.position.y;
                    bits[20] = LShoulderX;
                    bits[21] = LShoulderY;
                    points.push([count, LShoulderX, LShoulderY]);
                }
                if (i == posenet.partIds['rightShoulder']) {
                    var RShoulderX = keypoint.position.x;
                    var RShoulderY = keypoint.position.y;
                    bits[22] = RShoulderX;
                    bits[23] = RShoulderY;
                    points.push([count, RShoulderX, RShoulderY]);
                }
            }
            // console.log(points)

        }
    }

    /**
        A seeked event is fired when a seek operation completed, the current playback position has changed
        and the boolean seeking attribute is changed to false 
    **/

    video.addEventListener('seeked', function() {
        /**
            Video has been seeked, so now current frames 
            will show as we expect.  
        **/
        generateThumbnail(iter);
        //when frame is captured, add 0.1 seconds 
        tStamp += 0.1;
        count1++;
        // console.log("count:", count, "VS count1: ", count1)
            //If we haven't reached the end 

        /*if we have 0.1 added to this.duration, 
        we get an extra frame appened to CSV as compared to when we dont */
        if (tStamp <= this.duration + 0.1) {
            //will trigger another seeked event 
            this.currentTime = tStamp;
            // video.currentTime = video.currentTime;
            // console.log("-----in here-----")
        }
        // console.log("temp...", temp);
        // console.log("count....", count, "VS temp...", temp);
        // // if (count == count1 + 7) {
        else {

            // console.log("-----LOCATION CHANGE 2 -----");
            // console.log("printing", count1);
            // console.log("downloading here... numero 2 location....");
            document.getElementById("FinishedCompute").innerHTML = "Finished Computation Click Download Button"
            // link.click();
        }

        // console.log("tStamp: ", tStamp);
        // console.log("Vid.CurrentT === ", video.currentTime);
        // console.log("this.duration: ", this.duration);
    });

    function downloadMahCSV(){
        downloadMahCSV = function(){}; // kill it as soon as it was called
     console.log('Downloading CSV'); // your stuff here
     link.click();
};

    window.onload = setup;
</script> 

</html>